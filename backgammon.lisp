(defun sum= (l1 l2)
  (= (apply #'+ l1)
     (apply #'+ l2)))

(defun combos (nums &optional combos)
  (if (null nums)
      combos
      (combos (rest nums)
              (union (list (list (first nums)))
                     (union (mapcar (lambda (combo)
                                      (cons (first nums) combo))
                                    combos)
                            combos
                            :test #'sum=)
                     :test #'sum=))))

(defun backgammon-color-p (keyword)
  (member keyword '(:black :white)))
(deftype backgammon-color ()
  '(and keyword (satisfies backgammon-color-p)))

(defun backgammon-board-p (list)
  (and (listp list) (= 24 (length list))
       (every (lambda (point)
                 (or (null point)
                     (and (consp point)
                          (backgammon-color-p (first point))
                          (integerp (second point)))))
              list)))
(deftype backgammon-board ()
  '(and list (satisfies backgammon-board-p)))

(defconstant +white-bar+ 24)
(defconstant +white-goal+ -1)
(defconstant +black-bar+ -1)
(defconstant +black-goal+ 24)
(defconstant +total-pips+ 15)

(defparameter initial-board
  '((:black 2)
    () () () ()
    (:white 5)
    ()
    (:white 3)
    () () ()
    (:black 5)
    (:white 5)
    () () ()
    (:black 3)
    ()
    (:black 5)
    () () () ()
    (:white 2)))

(defclass backgammon ()
  ((points :initarg :points :reader points :type backgammon-board :initform initial-board)
   (dice :initarg :dice :reader dice :type list :initform '())
   (used-dice :initarg :used-dice :reader used-dice :type list :initform '())
   (turn :initarg :turn :reader turn :type (or backgammon-color null) :initform nil)
   (white-bar :initarg :white-bar :reader white-bar :type integer :initform 0)
   (black-bar :initarg :black-bar :reader black-bar :type integer :initform 0)
   (white-goal :initarg :white-goal :reader white-goal :type integer :initform 0)
   (black-goal :initarg :black-goal :reader black-goal :type integer :initform 0)
   (time-created :reader time-created :type integer :initform (get-universal-time))))
(defmethod finished-p ((game backgammon))
  (cond ((= 15 (white-goal game)) :white)
        ((= 15 (black-goal game)) :black)))
(defmethod point-color ((game backgammon) point)
  (cond ((and (= +black-bar+ point))
         (when (< 0 (black-bar game))
           :black))
        ((and (= +white-bar+ point))
         (when (< 0 (white-bar game))
           :white))
        (:else (first (nth point (points game))))))
(defmethod all-home-p ((game backgammon) color)
  (let ((home (apply #'subseq (points game)
                     (if (eq :black color)
                         '(18)
                         '(0 6)))))
    (= +total-pips+ (reduce (lambda (in-home point)
                    (+ in-home (if (eq color (first point))
                                   (second point)
                                   0)))
                  home
                  :initial-value ;; include the pips in goal
                  (if (eq :black color)
                      (black-goal game)
                      (white-goal game))))))
(defmethod valid-goal-p ((game backgammon) point die)
  (and point (member die (dice game))
       (<= 0 point 23)
       (nth point (points game))
       (or (<= point 6)
           (<= 18 point))
       (not (or (< point 0)
                (< 23 point)))
       (let* ((color (first (nth point (points game))))
              (home (apply #'subseq (points game)
                           (if (eq :black color)
                               '(18)
                               '(0 6))))
              (home (if (eq :black color)
                        (reverse home)
                        home))
              (point (if (< 6 point)
                         (abs (- point 23))
                         point)))
         (and (all-home-p game color)
              (or (= +white-goal+ (- point die))
                  (= 0 (reduce (lambda (above point)
                                 (+ above (if (eq color (first point))
                                              (second point)
                                              0)))
                               (subseq home (+ point 1))
                               :initial-value 0)))))))
(defmethod valid-move-p ((game backgammon) point die)
  ;; make sure dice are valid
  (with-slots (turn points) game
    (let ((color (point-color game point)))
      (and (not (finished-p game))
           point (member die (dice game))
           turn
           color (eq color (turn game))
           (if (eq :black color)
               (or (eq 0 (black-bar game))
                   (= point +black-bar+))
               (or (eq 0 (white-bar game))
                   (= point +white-bar+)))
           (let ((new-point (funcall (if (eq :black color)
                                         #'+ #'-)
                                     point die)))
             (cond
               ;; regular move
               ((and (<= 0 new-point 23)
                     (or (null (nth new-point points))
                         (eq (first (nth new-point points))
                             color)
                         (< (second (nth new-point points)) 2)))
                new-point)
               ;; goal
               ((valid-goal-p game point die)
                (if (eq :black color)
                    +black-goal+
                    +white-goal+))))))))
(defmethod can-move-p ((game backgammon))
  (and (turn game)
       (or (some (lambda (point index)
                   (and (eq (turn game) (first point))
                        (some (lambda (die)
                                (valid-move-p game index die))
                              (dice game))))
                 (points game)
                 (loop for n from 0 below 24 collect n))
           ;; check bars
           (some (lambda (die)
                   (valid-move-p game (if (eq :black (turn game))
                                          +black-bar+
                                          +white-bar+)
                                 die))
                 (dice game)))))
(defmethod roll-dice ((game backgammon))
  (if (or (not (turn game))
          (not (can-move-p game)))
      (multiple-value-bind (new-dice turn)
          (loop
            for d1 = (+ (random 6) 1) ;; white
            for d2 = (+ (random 6) 1) ;; black
            for turn = (if (turn game)
                           (if (eq :black (turn game))
                               :white
                               :black)
                           (cond ((< d1 d2) :black)
                                 ((< d2 d1) :white)))
            while (not turn)
            finally (return (values (if (= d1 d2)
                                        (list d1 d1 d1 d1)
                                        (list d1 d2))
                                    turn)))
        (make-instance
         'backgammon
         :points (points game)
         :dice new-dice
         :used-dice '()
         :turn turn
         :white-bar (white-bar game)
         :black-bar (black-bar game)
         :white-goal (white-goal game)
         :black-goal (black-goal game)))
      game))
(defmethod move ((game backgammon) point die)
  (with-slots (points turn) game
    (if (valid-move-p game point die)
        (let* ((color (point-color game point))
              (new-point (valid-move-p game point die))
               (new-color (or (point-color game new-point)
                              (when (= new-point +white-goal+)
                               :white)
                             (when (= new-point +black-goal+)
                               :black))))
          (make-instance
           'backgammon
           :points (mapcar (lambda (current-point index)
                             (cond
                               ((= index point)
                                (when (< 0 (- (second current-point) 1))
                                  (list color (- (second current-point) 1))))
                               ((= index new-point)
                                (list color (+ (if (eq color new-color)
                                                   (second current-point)
                                                   0)
                                               1)))
                               (:else current-point)))
                           points
                           (loop for n from 0 to 23 collect n))
           :dice (remove die (dice game) :count 1)
           :used-dice (cons die (used-dice game))
           :turn turn
           :white-bar (+ (white-bar game)
                         (cond ((= point +white-bar+) -1)
                               ((and (eq turn :black)
                                     (eq new-color :white)
                                     (not (= new-point +black-goal+)))
                                1)
                               (:else 0)))
           :black-bar (+ (black-bar game)
                         (cond ((= point +black-bar+) -1)
                               ((and (eq turn :white)
                                     (eq new-color :black)
                                     (not (= new-point +white-goal+)))
                                1)
                               (:else 0)))
           :white-goal (+ (white-goal game)
                          (if (= new-point +white-goal+) 1 0))
           :black-goal (+ (black-goal game)
                          (if (= new-point +black-goal+) 1 0))))
        game)))
(defmethod get-moves ((game backgammon) point)
  (with-slots (dice points) game
    (let ((combos (loop for combo in (combos dice)
                        collect combo
                        if (= 2 (length combo))
                          collect (reverse combo)))
          (color (point-color game point)))
      (when color
        (remove-if
         #'null
         (mapcar (lambda (combo)
                   (when (reduce (lambda (pair die)
                                   (when pair
                                     (let ((spot (valid-move-p (first pair) (second pair) die)))
                                       (when spot
                                         (list (move (first pair) (second pair) die)
                                               spot)))))
                                 combo :initial-value (list game point))
                     combo))
                 combos))))))
(defmethod get-point-move ((game backgammon) index pip)
  "Return the roll to move PIP to point INDEX or nil if it is impossible."
  (and pip (numberp pip) (<= -1 pip 24)
       (some (lambda (rolls)
               (when (= (or (second
                             (reduce (lambda (game--point die)
                                       (when (and game--point die)
                                         (multiple-value-bind (game point) (values-list game--point)
                                           (let ((spot (valid-move-p game point die)))
                                             (when spot
                                               (list (move game point die) spot))))))
                                     rolls :initial-value (list game pip)))
                            -2)
                        index)
                 rolls))
             (get-moves game pip))))
